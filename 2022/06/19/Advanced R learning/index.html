<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="学习之前：我的R已经大成！学习之后：我写的站的是R代码吗？为什么这些代码能正常工作？">
<meta property="og:type" content="article">
<meta property="og:title" content="Advanced R learning">
<meta property="og:url" content="https://biobrick.github.io/2022/06/19/Advanced%20R%20learning/">
<meta property="og:site_name" content="Bio Harbor">
<meta property="og:description" content="学习之前：我的R已经大成！学习之后：我写的站的是R代码吗？为什么这些代码能正常工作？">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-19T14:17:27.000Z">
<meta property="article:modified_time" content="2022-10-21T02:43:08.000Z">
<meta property="article:author" content="Chong Yin">
<meta name="twitter:card" content="summary"><title>Advanced R learning | Bio Harbor</title><link ref="canonical" href="https://biobrick.github.io/2022/06/19/Advanced%20R%20learning/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Bio Harbor</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Advanced R learning</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-06-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-21</span></span></div></header><div class="post-body"><hr>
<p>初次阅读，的确学到了挺多高级技术，甚至很多前所未见的东西，比如泛函和泛型……以后应该会时不时翻一下书，第一次理解还是比较浅显。</p>
<p>小技巧列表：</p>
<p>有时候，数据框读入了之后全变成了字符串，想变回数值类型，怎么办？</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtcars[] = lapply(mtcars, <span class="built_in">as.double</span>)</span><br></pre></td></tr></table></div></figure>
<p>注意这里为什么能用lapply，因为data.frame是特殊的列表<br>前面使用[]，实际上是选择全部子集，因此最后仍然是data.frame。如果不加前面这个，最后会将mtcars变成list</p>
<p>sapply是可以传参的，因为其中有…参数，会自动将后面多出来的参数对应到函数里面去<br>但需要注意拼写，因为…参数是不检查参数拼写的</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">function</span>(x,y,z=<span class="number">2</span>)&#123;x + y + z&#125;</span><br><span class="line">sapply(<span class="number">1</span>:<span class="number">5</span>, add, y=<span class="number">3</span>)</span><br></pre></td></tr></table></div></figure>
<p>do.call是传入参数列表的，而不是用来做list循环的~<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args = <span class="built_in">list</span>(<span class="number">1</span>:<span class="number">10</span>,na.rm = <span class="literal">TRUE</span>)</span><br><span class="line">do.call(mean,args)</span><br></pre></td></tr></table></div></figure><br>因此多次循环有两种处理方式：</p>
<ol>
<li>将每一次循环处理成参数型，用do.call传入</li>
<li>将每一次循环保存到一个list中，用apply函数族传入<br>二者的区别是，do.call实际上只运行一次函数，但参数是一个列表，但apply是运行多次函数，每一次读入数据的一部分<br>所以从性能考虑应该尽量使用apply函数族</li>
</ol>
<p>自定义中缀函数以实现灵活的小函数调用：<br>用户定义的中缀函数必须以%开头，以%结尾，所以，马上能想起来的自定义中缀函数是管道操作符：%&gt;%<br>用反引号括起来的中缀函数定义可以实现各种小功能的简单调用，例如：</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`%+%` = <span class="keyword">function</span>(a,b)&#123;paste(a,b,sep = <span class="string">&quot;&quot;</span>)&#125;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> %+% <span class="string">&quot;world!&quot;</span></span><br></pre></td></tr></table></div></figure>
<p>函数中可以使用on.exit构建退出触发式<br>如果在函数中使用了on.exit()函数，则在函数因任何情况退出时，会触发on.exsit中的表达式并执行<br>如果需要使用多个on.exit，必须显式传入参数add=TRUE,否则每次调用on.exit都会重写其中的内容<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adds = <span class="keyword">function</span>(x,y)&#123;</span><br><span class="line">  x+y</span><br><span class="line">  <span class="built_in">on.exit</span>(print(<span class="string">&quot;Done!&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">adds(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></div></figure><br>但是，on.exit不能替代stop或者message之类的响应函数，因为这个函数无论原函数怎么退出都会被执行</p>
<p>对于package，有两个特殊的环境，关系到函数调用，一个是软件包环境(package)，另一个就是命名空间环境(namespace)。<br>软件包环境中，包含了整个软件包里可以公共访问的一堆函数，例如stat软件包里，有sum,mean,var,sd等<br>而namespace中，则存在所有的函数，包括公共函数和内部函数，以及这些函数的绑定。<br>因此，在R中调用函数时，例如var,R会在globalenv中进行函数查找，然后去包的环境查找，如果没有就会报错，没有这个函数<br>但对于软件包中的函数，比如var，它依赖sd函数，但这个函数会首先去namespace中找，但永远不会去globalenv中进行查找<br>因此，软件包中自己定义的函数即便同名，通常也不会相互影响，因为都在各自的namepsace中，除非显式指定调用</p>
<p>延迟绑定与动态绑定：对赋值操作的进一步封装，使用%<d-%与%<a-%进行操作 延迟绑定，就是绑定的时候不生成对象，而是生成promise，在需要使用的时候才产生调用 动态绑定指不绑定到一个常量，而是绑定到一个动态变量上，每次调用都会进行计算 看上去可以用到循环上面进行一些高级操作： <figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(pryr)</span><br><span class="line"><span class="comment">#delay binding</span></span><br><span class="line">system.time(b %&lt;d-% &#123;Sys.sleep(<span class="number">3</span>);<span class="number">2</span>&#125;)</span><br><span class="line">system.time(b)</span><br></pre></td></tr></table></div><br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#activate binding</span></span><br><span class="line">require(pryr)</span><br><span class="line">x %&lt;a-% runif(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#first use</span></span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment">#second use</span></span><br><span class="line">x</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></d-%与%<a-%进行操作></p>
<p>R中有类似python的错误处理机制，主要有try、tryCatch和withCallingHandlers<br>try通常用来处理无条件无处理的异常，用try包住代码块即可。<br>try中的代码如果没有异常，则返回值就是正常函数的返回值，如果出现异常，则返回值是一个不可见的try-error对象<br>通过赋值操作可以给try中的函数返回设置默认值，如果函数出错，则使用默认值</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default &lt;- <span class="literal">NULL</span></span><br><span class="line">try(default &lt;- read.csv(<span class="string">&quot;some_wrong_file&quot;</span>),silent = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></div></figure>
<p>闭包closure，这是一个重要的概念，其有两个作用，其一是泛函编程，就是“返回函数的函数”，或者“定义在函数内的函数”<br>其二是扩展/维持变量作用域，定义在闭包内的变量可以被作用域外的变量访问到，联系就是闭包函数<br>R中的闭包主要用来做泛函编程，比如：<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">missing_fixer &lt;- <span class="keyword">function</span>(na_value)&#123;</span><br><span class="line">  <span class="keyword">function</span>(x)&#123;</span><br><span class="line">    x[x==na_value] &lt;- <span class="literal">NA</span></span><br><span class="line">    x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想把-99转换为NA，首先创建闭包函数，然后配合lapply就行了</span></span><br><span class="line">fix_missing_99 &lt;- missing_fixer(-<span class="number">99</span>)</span><br><span class="line">df[] &lt;- lapply(df, fix_missing_99)</span><br></pre></td></tr></table></div></figure></p>
<p>匿名函数，由于R中函数本身就是对象（其实python里也是），因此函数不一定需要与名字进行bind<br>因此，函数很短的时候，无需绑定函数名，即为匿名函数，匿名函数除了没有名字，定义起来和普通函数一样<br>匿名函数同样存在作用域，而且通常只对base内置的函数进行匿名调用，避免R不知道我们调用的是匿名函数而出现错误<br>当然，使用匿名函数写起来可能很轻松，但是这会降低代码的可读性和理解性，尽量不要大范围的使用匿名函数</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lapply(mtcars,<span class="keyword">function</span>(x) <span class="built_in">length</span>(unique(x)))</span><br></pre></td></tr></table></div></figure>
<p>匿名函数的重要作用就是用来创建闭包，闭包打包了父环境和子环境，能够跨环境进行数据和操作访问，其实上面闭包的例子<br>function(x)就是一个匿名函数<br>闭包的父环境，是创建闭包的外部函数的环境，无论它是globalenv还是其他环境。</p>
<p>函数列表，由于函数本身是对象，因此函数可以像数据一样以list的形式保存，这样可以很方便地运行一组功能关联的函数<br>从列表中使用函数也很简单，提取然后使用即可<br>例如一组跟数据汇总相关的函数：<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">compute_mean &lt;- <span class="built_in">list</span>(</span><br><span class="line">  base = <span class="keyword">function</span>(x) mean(x),</span><br><span class="line">  <span class="built_in">sum</span> = <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x) / <span class="built_in">length</span>(x),</span><br><span class="line">  manual = <span class="keyword">function</span>(x) &#123;</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    n &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">seq_along</span>(x))&#123;</span><br><span class="line">      total &lt;- total + x[i]/n</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">x &lt;- runif(<span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">compute_mean$base(x)</span><br><span class="line">compute_mean$<span class="built_in">sum</span>(x)</span><br><span class="line">compute_meanmanual(x)</span><br></pre></td></tr></table></div></figure><br>或者，在保持内外向量名一致的情况下，可以直接用lapply进行调用,当然前提你得知道拟调用的是一个函数列表<br>此外，如果想添加一些额外参数，那么可以再lapply调用中添加一些额外参数<br>不过这里再次强调，这里是不会进行拼写检查的，因此…..得保证输入是正确的</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lapply(compute_mean,<span class="keyword">function</span>(f) f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#if omit na is necesary</span></span><br><span class="line">lapply(compute_mean,<span class="keyword">function</span>(f) f(x,na.rm=<span class="literal">TRUE</span>))</span><br></pre></td></tr></table></div></figure>
<p>函数列表的一个重要价值是不将函数直接保存在公共的environment中，有些函数可能造成冲突，或者其实就只想用一次<br>因此，为了对函数之间的冲突进行限制，可以使用with、attach+detach和list2env+rm，将函数列表引入全局，用完再删；<br>但一定要记得处理掉全局环境中引入的函数，以防发生冲突。</p>
<p>for循环泛函lapply/sapply/vapply与其他<br>这里要说的不是apply家族，这个家族用的很多，很熟悉。这里引入一个小问题：有两个列表，一个是观测值，一个是权重<br>怎么循环计算加权平均？<br>这里用lapply当然可以解决，但是得双重循环，很麻烦，有个更好的解决方案，用Map函数，注意不是purrr里的map</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xs &lt;- replicate(<span class="number">5</span>,runif(<span class="number">10</span>),simplify = <span class="literal">FALSE</span>)</span><br><span class="line">ws &lt;- replicate(<span class="number">5</span>,rpois(<span class="number">10</span>,<span class="number">5</span>)+<span class="number">1</span>,simplify = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">unlist(Map(weighted.mean,xs,ws))</span><br></pre></td></tr></table></div></figure>
<p>本质上就是因为，这里需要对xs中的每一个元素，计算匹配的每一ws元素，调用weight.mean函数并作为两个匹配的参数传入<br>lapply只有一个list可变调用，其余全都是固定的，Map就是为了解决这个问题。<br>此时，如果我们还需要传入一些常量，那么可以用匿名函数<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlist(Map(<span class="keyword">function</span>(x,w) weighted.mean(x,w,na.rm=<span class="literal">TRUE</span>),xs,ws))</span><br></pre></td></tr></table></div></figure></p>
<p>从这些例子能看到，在执行复杂需求的时候，除了原型函数，天然需要考虑到apply/Map/sapply/vapply和泛函实现<br>也即：如果需要重复执行一条函数，则应该考虑使用apply和Map<br>如果需要重复使用一类函数，则应该考虑使用泛函<br>如果循环数非常多，而且可以用lapply进行，则可以考虑并行化<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boot_df &lt;- <span class="keyword">function</span>(x) x[sample(nrow(x),replace = <span class="built_in">T</span>),]</span><br><span class="line">rsquard &lt;- <span class="keyword">function</span>(mod) summary(mod)$r.square</span><br><span class="line">boot_lm &lt;- <span class="keyword">function</span>(i)&#123;</span><br><span class="line">  rsquard(lm(mpg ~ wt + disp,data = boot_df(mtcars)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#非并行化运算：</span></span><br><span class="line">system.time(lapply(<span class="number">1</span>:<span class="number">500</span>, boot_lm))</span><br><span class="line"></span><br><span class="line"><span class="comment">#并行化运算：</span></span><br><span class="line">require(parallel)</span><br><span class="line">system.time(mclapply(<span class="number">1</span>:<span class="number">500</span>,boot_lm))</span><br></pre></td></tr></table></div></figure></p>
<p>对于需要递归的场景，一个常见的例子是Reduce函数，这是各种函数式语言都支持的（其实Map也是）<br>Reduce用于将某个函数f依次应用于一个列表，而且每一次只取前两个元素，返回一个结果，与下一个元素组合继续进行f<br>最常见的例子，是多重列表取交集，以一个极其简单的办法就能实现任意多的列表取交集<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l &lt;- replicate(<span class="number">5</span>,sample(<span class="number">1</span>:<span class="number">10</span>,<span class="number">15</span>,replace = <span class="built_in">T</span>),simplify = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">Reduce(intersect,l)</span><br></pre></td></tr></table></div></figure><br>泛函用起来非常强大，但是，泛函并不能解决全部的问题，通常使用泛函与否的判断条件是，如果以泛函解决问题能让编码更加简洁，那么泛函是一个好主意，但是，如果在某个问题中使用泛函导致代码复杂化或者难以理解，那使用泛函就不是一个好主意了。<br>常见的无法（或者说不应当）使用泛函的场景有：<br>1.原位修改，比如对数据框中某一列数值部分数值进行修改，那么应当直接使用循环<br>2.递归关系，如果在循环的时候，第i次循环与第i-1次不独立，那么便几乎无法使用泛函<br>3.while循环，泛函有一个显著特点，就是知道循环执行多少次，但是有些while并不知道要运行多少次，因此通常不进行转换</p>
<p>组合函数运算，函数之间是可以进行运算的，例如连接，包装，组合，R中提供了对应的方法<br>例如plyr包中的each函数，能够组合多个函数，它接收多个函数并将这些函数变成函数列表，能更进一步简化调用<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sums &lt;- plyr::each(mean,sd,median)</span><br><span class="line">sums(<span class="number">1</span>:<span class="number">50</span>)</span><br></pre></td></tr></table></div></figure><br>或者pryr中的compose，它接收函数并进行复合，即将f(x)和g(x)复合为f(g(x))，马上就能联想到一个应用场景<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sapply(mtcars,pryr::compose(<span class="built_in">length</span>,unique))</span><br></pre></td></tr></table></div></figure><br>每次调用compoese也还是有点麻烦，因此，联想到之前的中缀函数，可以直接自己定义中缀函数即可<br><code>%o%</code> &lt;- pryr::compose<br>然后就可以直接使用中缀函数进行函数复合了</p>
<p>非标准计算，subs,substitute与eval<br>非标准计算通常用于交互式场景，与标准计算相对，其本质是，获取我们输入的“表达式”本身，而不是对表达式进行求值<br>最常见的ggplot2，在调用的时候，例如dplyr中的各种函数，有没有好奇过为什么例如select可以直接输入列名？<br>因为在执行计算之前，dplyr将我们所有输入的信息，转换为纯粹的表达式，而不进行表达式的计算，例如我们输入一个为X1的列明，在进行运算之前，dplyr将X1捕获，并生成一个表达式colname=X1，此时，R没有对我们输入的式子进行运算，而是像写草稿一样，将它们写下来，然后统一进行运算，及保持表达式形式的计算。<br>这非常有用，比如我们在函数中，希望对x+y这个简单的式子，进行一些操作，因此我们需要保留这个表达式的形式，而不是每次直接进行了计算。所以我们需要substitute，它返回我们输入的表达式。例如</p>
<figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">substitute</span>(x+y)</span><br></pre></td></tr></table></div></figure>
<p>看到了吗，它直接返回了表达式，这非常有用，例如对于X可变的循环中，对，就是在ggplot2的循环作图里面。<br>如果我们想计算它的值，需要用到eval，eval的意思就是对表达式进行运算，它返回表达式的值，二者通常配合使用，substitute用来构建可变表达式，eval用来进行运算。<br>如果要构建可变表达式，那么需要然substitute返回可变的表达式形式，这可以使用添加list参数来进行<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">substitute</span>(x+y,<span class="built_in">list</span>(x=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">pryr::subs(x+y,<span class="built_in">list</span>(x=<span class="number">1</span>))</span><br></pre></td></tr></table></div></figure><br>由于在R中，任何操作都是函数调用，所以我们其实连函数调用都能进行赋值<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pryr::subs(x+y,<span class="built_in">list</span>(<span class="string">&quot;+&quot;</span> = <span class="built_in">quote</span>(`*`)))</span><br></pre></td></tr></table></div></figure><br>当表达式构建好之后，调用eval对表达式进行求值即可<br>但是NSE的使用会使得函数失去透明性，也即输入同等的值的引用，返回同样的结果，但NES不是，向NSE的函数中输入x=10,y=10和10很可能出现不同的结果，这使得对于函数的预测非常困难，因此需要谨慎使用，除非有较大的效率提升。</p>
<p>在OOP方面，目前最先进的是R6对象，其次是最流行的S4对象，后者常见于生物信息中，前者则构成了重要的mlr3learn框架<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require(R6)</span><br><span class="line">Accumulator &lt;- R6Class(<span class="string">&quot;Accumulator&quot;</span>, <span class="built_in">list</span>(</span><br><span class="line">  <span class="built_in">sum</span> = <span class="number">0</span>,</span><br><span class="line">  add = <span class="keyword">function</span>(x = <span class="number">1</span>) &#123;</span><br><span class="line">    self$sum &lt;- self$<span class="built_in">sum</span> + x </span><br><span class="line">    <span class="built_in">invisible</span>(self)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>R6类中带有new方法，这是内置的，用来创建一个新的R6对象，这与其他语言创建新对象差不多。<br>其实R6对象的常见的方法、形式与诸如python中对象的定义已经非常相似了，在R6对象中，方法(method)已经是对象了，而不再是S4中的泛型，这使得对象中方法的调用可以直接用$调用方法对象来进行。<br>此外，上面的那个R6对象，是一个R6Generate，与python不一样的是，R6对象直接就实例化了，不用专门实例化，当然在编程中这不是一个好主意，因为通常更加具体的对象拥有很多私有方法，通常这用继承来解决，因此，最好是采用跟其他脚本语言中一样的习惯，以一个R6对象作为基础，重新实例化和继承出新的即时使用的对象。<br>对于方法，R6中方法的使用和普通调用函数几乎一样，都是调用，使用参数，区别是返回值通常是invisible的返回给了self的某个属性。<br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- Accumulator$new()</span><br><span class="line"></span><br><span class="line">x$add(<span class="number">4</span>)</span><br><span class="line">x$<span class="built_in">sum</span></span><br></pre></td></tr></table></div></figure><br><figure class="highlight r"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x$add()</span><br><span class="line">x$<span class="built_in">sum</span></span><br></pre></td></tr></table></div></figure></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://biobrick.github.io">Chong Yin</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://biobrick.github.io/2022/06/19/Advanced%20R%20learning/">https://biobrick.github.io/2022/06/19/Advanced%20R%20learning/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/alipay.png"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/wechatpay.png"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/10/19/UCSCXENA/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">UCSCXENA?</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/05/18/%E7%89%A9%E7%A7%8D%E9%97%B4%E5%9F%BA%E5%9B%A0%E4%BA%92%E6%8D%A2/"><span class="paginator-prev__text">物种间基因互换</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/BIOBRICK/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="386396663" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">归档</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Chong Yin</span></div><div><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>